// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'setting_change_pin_store.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SettingChangePinStateTearOff {
  const _$SettingChangePinStateTearOff();

  OldPin oldPin() {
    return const OldPin();
  }

  OldPinError oldPinError() {
    return const OldPinError();
  }

  NewPin newPin() {
    return const NewPin();
  }

  ConfirmNewPin confirmNewPin() {
    return const ConfirmNewPin();
  }

  ConfirmNewPinError confirmNewPinError() {
    return const ConfirmNewPinError();
  }
}

/// @nodoc
const $SettingChangePinState = _$SettingChangePinStateTearOff();

/// @nodoc
mixin _$SettingChangePinState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() oldPin,
    required TResult Function() oldPinError,
    required TResult Function() newPin,
    required TResult Function() confirmNewPin,
    required TResult Function() confirmNewPinError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OldPin value) oldPin,
    required TResult Function(OldPinError value) oldPinError,
    required TResult Function(NewPin value) newPin,
    required TResult Function(ConfirmNewPin value) confirmNewPin,
    required TResult Function(ConfirmNewPinError value) confirmNewPinError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingChangePinStateCopyWith<$Res> {
  factory $SettingChangePinStateCopyWith(SettingChangePinState value,
          $Res Function(SettingChangePinState) then) =
      _$SettingChangePinStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SettingChangePinStateCopyWithImpl<$Res>
    implements $SettingChangePinStateCopyWith<$Res> {
  _$SettingChangePinStateCopyWithImpl(this._value, this._then);

  final SettingChangePinState _value;
  // ignore: unused_field
  final $Res Function(SettingChangePinState) _then;
}

/// @nodoc
abstract class $OldPinCopyWith<$Res> {
  factory $OldPinCopyWith(OldPin value, $Res Function(OldPin) then) =
      _$OldPinCopyWithImpl<$Res>;
}

/// @nodoc
class _$OldPinCopyWithImpl<$Res>
    extends _$SettingChangePinStateCopyWithImpl<$Res>
    implements $OldPinCopyWith<$Res> {
  _$OldPinCopyWithImpl(OldPin _value, $Res Function(OldPin) _then)
      : super(_value, (v) => _then(v as OldPin));

  @override
  OldPin get _value => super._value as OldPin;
}

/// @nodoc

class _$OldPin extends OldPin {
  const _$OldPin() : super._();

  @override
  String toString() {
    return 'SettingChangePinState.oldPin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is OldPin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() oldPin,
    required TResult Function() oldPinError,
    required TResult Function() newPin,
    required TResult Function() confirmNewPin,
    required TResult Function() confirmNewPinError,
  }) {
    return oldPin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
  }) {
    return oldPin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (oldPin != null) {
      return oldPin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OldPin value) oldPin,
    required TResult Function(OldPinError value) oldPinError,
    required TResult Function(NewPin value) newPin,
    required TResult Function(ConfirmNewPin value) confirmNewPin,
    required TResult Function(ConfirmNewPinError value) confirmNewPinError,
  }) {
    return oldPin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
  }) {
    return oldPin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (oldPin != null) {
      return oldPin(this);
    }
    return orElse();
  }
}

abstract class OldPin extends SettingChangePinState {
  const factory OldPin() = _$OldPin;
  const OldPin._() : super._();
}

/// @nodoc
abstract class $OldPinErrorCopyWith<$Res> {
  factory $OldPinErrorCopyWith(
          OldPinError value, $Res Function(OldPinError) then) =
      _$OldPinErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$OldPinErrorCopyWithImpl<$Res>
    extends _$SettingChangePinStateCopyWithImpl<$Res>
    implements $OldPinErrorCopyWith<$Res> {
  _$OldPinErrorCopyWithImpl(
      OldPinError _value, $Res Function(OldPinError) _then)
      : super(_value, (v) => _then(v as OldPinError));

  @override
  OldPinError get _value => super._value as OldPinError;
}

/// @nodoc

class _$OldPinError extends OldPinError {
  const _$OldPinError() : super._();

  @override
  String toString() {
    return 'SettingChangePinState.oldPinError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is OldPinError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() oldPin,
    required TResult Function() oldPinError,
    required TResult Function() newPin,
    required TResult Function() confirmNewPin,
    required TResult Function() confirmNewPinError,
  }) {
    return oldPinError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
  }) {
    return oldPinError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (oldPinError != null) {
      return oldPinError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OldPin value) oldPin,
    required TResult Function(OldPinError value) oldPinError,
    required TResult Function(NewPin value) newPin,
    required TResult Function(ConfirmNewPin value) confirmNewPin,
    required TResult Function(ConfirmNewPinError value) confirmNewPinError,
  }) {
    return oldPinError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
  }) {
    return oldPinError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (oldPinError != null) {
      return oldPinError(this);
    }
    return orElse();
  }
}

abstract class OldPinError extends SettingChangePinState {
  const factory OldPinError() = _$OldPinError;
  const OldPinError._() : super._();
}

/// @nodoc
abstract class $NewPinCopyWith<$Res> {
  factory $NewPinCopyWith(NewPin value, $Res Function(NewPin) then) =
      _$NewPinCopyWithImpl<$Res>;
}

/// @nodoc
class _$NewPinCopyWithImpl<$Res>
    extends _$SettingChangePinStateCopyWithImpl<$Res>
    implements $NewPinCopyWith<$Res> {
  _$NewPinCopyWithImpl(NewPin _value, $Res Function(NewPin) _then)
      : super(_value, (v) => _then(v as NewPin));

  @override
  NewPin get _value => super._value as NewPin;
}

/// @nodoc

class _$NewPin extends NewPin {
  const _$NewPin() : super._();

  @override
  String toString() {
    return 'SettingChangePinState.newPin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is NewPin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() oldPin,
    required TResult Function() oldPinError,
    required TResult Function() newPin,
    required TResult Function() confirmNewPin,
    required TResult Function() confirmNewPinError,
  }) {
    return newPin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
  }) {
    return newPin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (newPin != null) {
      return newPin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OldPin value) oldPin,
    required TResult Function(OldPinError value) oldPinError,
    required TResult Function(NewPin value) newPin,
    required TResult Function(ConfirmNewPin value) confirmNewPin,
    required TResult Function(ConfirmNewPinError value) confirmNewPinError,
  }) {
    return newPin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
  }) {
    return newPin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (newPin != null) {
      return newPin(this);
    }
    return orElse();
  }
}

abstract class NewPin extends SettingChangePinState {
  const factory NewPin() = _$NewPin;
  const NewPin._() : super._();
}

/// @nodoc
abstract class $ConfirmNewPinCopyWith<$Res> {
  factory $ConfirmNewPinCopyWith(
          ConfirmNewPin value, $Res Function(ConfirmNewPin) then) =
      _$ConfirmNewPinCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfirmNewPinCopyWithImpl<$Res>
    extends _$SettingChangePinStateCopyWithImpl<$Res>
    implements $ConfirmNewPinCopyWith<$Res> {
  _$ConfirmNewPinCopyWithImpl(
      ConfirmNewPin _value, $Res Function(ConfirmNewPin) _then)
      : super(_value, (v) => _then(v as ConfirmNewPin));

  @override
  ConfirmNewPin get _value => super._value as ConfirmNewPin;
}

/// @nodoc

class _$ConfirmNewPin extends ConfirmNewPin {
  const _$ConfirmNewPin() : super._();

  @override
  String toString() {
    return 'SettingChangePinState.confirmNewPin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConfirmNewPin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() oldPin,
    required TResult Function() oldPinError,
    required TResult Function() newPin,
    required TResult Function() confirmNewPin,
    required TResult Function() confirmNewPinError,
  }) {
    return confirmNewPin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
  }) {
    return confirmNewPin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (confirmNewPin != null) {
      return confirmNewPin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OldPin value) oldPin,
    required TResult Function(OldPinError value) oldPinError,
    required TResult Function(NewPin value) newPin,
    required TResult Function(ConfirmNewPin value) confirmNewPin,
    required TResult Function(ConfirmNewPinError value) confirmNewPinError,
  }) {
    return confirmNewPin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
  }) {
    return confirmNewPin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (confirmNewPin != null) {
      return confirmNewPin(this);
    }
    return orElse();
  }
}

abstract class ConfirmNewPin extends SettingChangePinState {
  const factory ConfirmNewPin() = _$ConfirmNewPin;
  const ConfirmNewPin._() : super._();
}

/// @nodoc
abstract class $ConfirmNewPinErrorCopyWith<$Res> {
  factory $ConfirmNewPinErrorCopyWith(
          ConfirmNewPinError value, $Res Function(ConfirmNewPinError) then) =
      _$ConfirmNewPinErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfirmNewPinErrorCopyWithImpl<$Res>
    extends _$SettingChangePinStateCopyWithImpl<$Res>
    implements $ConfirmNewPinErrorCopyWith<$Res> {
  _$ConfirmNewPinErrorCopyWithImpl(
      ConfirmNewPinError _value, $Res Function(ConfirmNewPinError) _then)
      : super(_value, (v) => _then(v as ConfirmNewPinError));

  @override
  ConfirmNewPinError get _value => super._value as ConfirmNewPinError;
}

/// @nodoc

class _$ConfirmNewPinError extends ConfirmNewPinError {
  const _$ConfirmNewPinError() : super._();

  @override
  String toString() {
    return 'SettingChangePinState.confirmNewPinError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConfirmNewPinError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() oldPin,
    required TResult Function() oldPinError,
    required TResult Function() newPin,
    required TResult Function() confirmNewPin,
    required TResult Function() confirmNewPinError,
  }) {
    return confirmNewPinError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
  }) {
    return confirmNewPinError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? oldPin,
    TResult Function()? oldPinError,
    TResult Function()? newPin,
    TResult Function()? confirmNewPin,
    TResult Function()? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (confirmNewPinError != null) {
      return confirmNewPinError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OldPin value) oldPin,
    required TResult Function(OldPinError value) oldPinError,
    required TResult Function(NewPin value) newPin,
    required TResult Function(ConfirmNewPin value) confirmNewPin,
    required TResult Function(ConfirmNewPinError value) confirmNewPinError,
  }) {
    return confirmNewPinError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
  }) {
    return confirmNewPinError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OldPin value)? oldPin,
    TResult Function(OldPinError value)? oldPinError,
    TResult Function(NewPin value)? newPin,
    TResult Function(ConfirmNewPin value)? confirmNewPin,
    TResult Function(ConfirmNewPinError value)? confirmNewPinError,
    required TResult orElse(),
  }) {
    if (confirmNewPinError != null) {
      return confirmNewPinError(this);
    }
    return orElse();
  }
}

abstract class ConfirmNewPinError extends SettingChangePinState {
  const factory ConfirmNewPinError() = _$ConfirmNewPinError;
  const ConfirmNewPinError._() : super._();
}
